/*
 * Parser.h
 *
 *  Created on: 11.10.2015
 *      Author: ugin
 */

#ifndef PARSER_H_
#define PARSER_H_

#include "lexer/lexer.h"
#include <stdio.h>
#include <vector>
#include "Node.h"

using namespace std;

class Parser {
private:
	/*
	%term <const char*> @SEMRULE.
	grammar = [@SEMRULE] init rule {rule} [@SEMRULE].
	init = [term_decl] [nonterm_decl].

	term_decl = '%term' [attr] @TERM {',' [attr]  @TERM} '.' .
	nonterm_decl = '%nonterm' [attr] @NONTERM
			{ ',' [attr] @NONTERM }  '.' .

	attr = '<' ( 'int' | 'char' | 'const char*' ) '>' .
	rule = @NONTERM [@SEMRULE]'=' multi_addendum '.' .
	multi_addendum = addendum {'|' addendum}.
	addendum = factor [@SEMRULE] {factor [@SEMRULE] }.
	factor = '[' multi_addendum ']' |
			  '{' multi_addendum '}' |
			   '(' multi_addendum ')' |
			    ident | .
	ident = @TERM | @NONTERM .
	*/
	Node* root;
	int num;
	vector<YYSTYPE> tokens;
	YYSTYPE sym;
	YYSTYPE nextToken();
	void parseGrammar(Node *parent);
	void parseInit(Node *parent);
	void parseTermDecl(Node *parent);
	void parseNonTermDecl(Node *parent);
	void parseAttribute(Node *parent);
	void parseRule(Node *parent);
	void parseMultiAddendum(Node *parent);
	void parseAddendum(Node *parent);
	void parseFactor(Node *parent);
	void parseIdent(Node *parent);
	void expectedToken(Node *parent, int tag);

public:
	Node* parse();
	Parser(vector<YYSTYPE> t);
	virtual ~Parser();
};

#endif /* PARSER_H_ */
