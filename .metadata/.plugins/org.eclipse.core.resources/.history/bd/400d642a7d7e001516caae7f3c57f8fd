//============================================================================
// Name        : NeedlmanWucnsh_N.cpp
// Author      : 
// Version     :
// Copyright   : Your copyright notice
// Description : Hello World in C++, Ansi-style
//============================================================================

#include <iostream>
#include <string>
#include "ArrayWithState.h"

using namespace std;

int align(string s[], int n) {
/*			// s_new
			String newValueForS1 = "";
	        String newValueForS2 = "";
	        int n1 = s1.value.length() + 1;
	        int n2 = s2.value.length() + 1;
	        int i,j;

	        // объявляю одну многомерную матрицу
	        double[][] M = new double[n1][];
	        int[][] P = new int[n1][];


	        for (i=0; i<n1; i++) {
	            M[i] = new double[n2];
	            P[i] = new int[n2];
	        }

	        //инициализирую начало
	        //заполняем все краевые элементы
	        M[0][0] = 0;
	        P[0][0] = 0;

	        for (i=1; i<n1; i++) {
	            M[i][0] = performer.GAP_PENALTY*i;
	            P[i][0] = performer.UP;
	        }

	        for (j=1;j<n2;j++) {
	            M[0][j] = performer.GAP_PENALTY*j;
	            P[0][j] = performer.LEFT;
	        }

	        //заполняю матрицу
	        //бежим по матрице и заносим максимально возможный скор движения из предыдущих клеток (нужна формула)
	        for (i=1; i<n1; i++) {
	            for (j=1; j<n2; j++) {
	                int symNumber1 = performer.charToInt.get(s1.value.charAt(i-1));
	                int symNumber2 = performer.charToInt.get(s2.value.charAt(j-1));
	                double leftAndUpValue = M[i-1][j-1] + performer.similarityMatrix[symNumber1][symNumber2];
	                double leftValue = M[i][j-1] + performer.GAP_PENALTY;
	                double upValue = M[i-1][j] + performer.GAP_PENALTY;

	                M[i][j] = max(leftAndUpValue, leftValue, upValue);

	                if (M[i][j] == leftAndUpValue) {
	                    P[i][j] = performer.LEFT_AND_UP;
	                }
	                if (M[i][j] == leftValue) {
	                    P[i][j] = performer.LEFT;
	                }
	                if (M[i][j] == upValue) {
	                    P[i][j] = performer.UP;
	                }
	            }
	        }
	        print(M);

	        //обратный ход
	        for (i=n1-1,j=n2-1;P[i][j]!=0;) {
	            if (P[i][j]==performer.LEFT_AND_UP) {
	                newValueForS1 =  s1.value.charAt(i-1) + newValueForS1;
	                newValueForS2 = s2.value.charAt(j-1) + newValueForS2;
	                i--;
	                j--;
	                continue;
	            }
	            if (P[i][j]==performer.LEFT) {
	                newValueForS1 = '-' + newValueForS1;
	                newValueForS2 = s2.value.charAt(j-1) + newValueForS2;
	                j--;
	                continue;
	            }
	            if (P[i][j]==performer.UP) {
	                newValueForS1 = s1.value.charAt(i-1) + newValueForS1;
	                newValueForS2 = '-' + newValueForS2;
	                i--;
	            }
	        }

	        s1.value = newValueForS1;
	        s2.value = newValueForS2;
	        return M[n1-1][n2-1];*/
}

int main() {
	int n;
	int i;
	cin >> n;
	string s[n];
	for (i=0; i<n; i++) {
		cin >> s[i];
	}




	cout << "!!!Hello World!!!" << endl; // prints !!!Hello World!!!


	return 0;
}
