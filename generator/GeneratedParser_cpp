#include "GeneratedParser.h"
Node* GeneratedParser::parse() {
	parseGrammar(root)
	if (sym->tag!=0)
		throw runtime_error("expected EOF!");
	return root;
}
YYSTYPE* GeneratedParser::nextToken() {
	if (num<tokens.size())
		return tokens[++num];
	else
		return tokens[num];
}
void GeneratedParser::expectedToken(Node *parent, int tag) {
	if (sym->tag == tag) {
		return tokens[++num];
	} else {
		throw runtime_error(
			"UnexpectedToken:"
			+string(Domains[sym->tag])
			+" instead of: "
			+"\n");
}
GeneratedParser::GeneratedParser() {
	num = 0;
	this->tokens = t;
	sym = tokens[0];
	root = new Node(NULL);
}
GeneratedParser::~GeneratedParser() {}
void GeneratedParser::parse_grammar(Node *parent) {
	if (SP_SEM_RULE) {
		expectedToken(parent->addChild(new Node(parent,sym)), SP_SEM_RULE)
		break;
	}
	parse_init(parent->addChild(new Node(parent)));
	parse_rule(parent->addChild(new Node(parent)));
	while (SP_NON_TERM) {
		parse_rule(parent->addChild(new Node(parent)));
		break;
	}
	if (SP_SEM_RULE) {
		expectedToken(parent->addChild(new Node(parent,sym)), SP_SEM_RULE)
		break;
	}
	break;
}
void GeneratedParser::parse_init(Node *parent) {
	if (SP_DECL_TERM) {
		parse_term_decl(parent->addChild(new Node(parent)));
		break;
	}
	if (SP_DECL_NONTERM) {
		parse_nonterm_decl(parent->addChild(new Node(parent)));
		break;
	}
	break;
}
void GeneratedParser::parse_term_decl(Node *parent) {
	expectedToken(parent->addChild(new Node(parent,sym)), SP_DECL_TERM)
	if (SP_L_TR_BRACKET) {
		parse_attr(parent->addChild(new Node(parent)));
		break;
	}
	expectedToken(parent->addChild(new Node(parent,sym)), TERM)
	while (SP_COMMA) {
		expectedToken(parent->addChild(new Node(parent,sym)), SP_COMMA)
		if (SP_L_TR_BRACKET) {
			parse_attr(parent->addChild(new Node(parent)));
			break;
		}
		expectedToken(parent->addChild(new Node(parent,sym)), TERM)
		break;
	}
	expectedToken(parent->addChild(new Node(parent,sym)), SP_DOT)
	break;
}
void GeneratedParser::parse_nonterm_decl(Node *parent) {
	expectedToken(parent->addChild(new Node(parent,sym)), SP_DECL_NONTERM)
	if (SP_L_TR_BRACKET) {
		parse_attr(parent->addChild(new Node(parent)));
		break;
	}
	expectedToken(parent->addChild(new Node(parent,sym)), SP_NON_TERM)
	while (SP_COMMA) {
		expectedToken(parent->addChild(new Node(parent,sym)), SP_COMMA)
		if (SP_L_TR_BRACKET) {
			parse_attr(parent->addChild(new Node(parent)));
			break;
		}
		expectedToken(parent->addChild(new Node(parent,sym)), SP_NON_TERM)
		break;
	}
	expectedToken(parent->addChild(new Node(parent,sym)), SP_DOT)
	break;
}
void GeneratedParser::parse_attr(Node *parent) {
	expectedToken(parent->addChild(new Node(parent,sym)), SP_L_TR_BRACKET)
	expectedToken(parent->addChild(new Node(parent,sym)), SP_TYPE)
	expectedToken(parent->addChild(new Node(parent,sym)), SP_R_TR_BRACKET)
	break;
}
void GeneratedParser::parse_rule(Node *parent) {
	expectedToken(parent->addChild(new Node(parent,sym)), SP_NON_TERM)
	if (SP_SEM_RULE) {
		expectedToken(parent->addChild(new Node(parent,sym)), SP_SEM_RULE)
		break;
	}
	expectedToken(parent->addChild(new Node(parent,sym)), SP_EQUAL)
	parse_multi_addendum(parent->addChild(new Node(parent)));
	expectedToken(parent->addChild(new Node(parent,sym)), SP_DOT)
	break;
}
void GeneratedParser::parse_multi_addendum(Node *parent) {
	parse_addendum(parent->addChild(new Node(parent)));
	while (SP_DIR_SLASH) {
		expectedToken(parent->addChild(new Node(parent,sym)), SP_DIR_SLASH)
		parse_addendum(parent->addChild(new Node(parent)));
		break;
	}
	break;
}
void GeneratedParser::parse_addendum(Node *parent) {
	parse_factor(parent->addChild(new Node(parent)));
	if (SP_SEM_RULE) {
		expectedToken(parent->addChild(new Node(parent,sym)), SP_SEM_RULE)
		break;
	}
	while (TERM||SP_NON_TERM||SP_SEM_RULE||SP_L_SQ_BRACKET||SP_L_BRACE||SP_L_PARENT) {
		parse_factor(parent->addChild(new Node(parent)));
		if (SP_SEM_RULE) {
			expectedToken(parent->addChild(new Node(parent,sym)), SP_SEM_RULE)
			break;
		}
		break;
	}
	break;
}
void GeneratedParser::parse_factor(Node *parent) {
	switch(sym->tag) {
		case SP_L_SQ_BRACKET:
			expectedToken(parent->addChild(new Node(parent,sym)), SP_L_SQ_BRACKET)
			parse_multi_addendum(parent->addChild(new Node(parent)));
			expectedToken(parent->addChild(new Node(parent,sym)), SP_R_SQ_BRACKET)
			break;
		case SP_L_BRACE:
			expectedToken(parent->addChild(new Node(parent,sym)), SP_L_BRACE)
			parse_multi_addendum(parent->addChild(new Node(parent)));
			expectedToken(parent->addChild(new Node(parent,sym)), SP_R_BRACE)
			break;
		case SP_L_PARENT:
			expectedToken(parent->addChild(new Node(parent,sym)), SP_L_PARENT)
			parse_multi_addendum(parent->addChild(new Node(parent)));
			expectedToken(parent->addChild(new Node(parent,sym)), SP_R_PARENT)
			break;
		case TERM:
			parse_ident(parent->addChild(new Node(parent)));
			break;
		case SP_NON_TERM:
			parse_ident(parent->addChild(new Node(parent)));
			break;
	}
}
void GeneratedParser::parse_ident(Node *parent) {
	switch(sym->tag) {
		case TERM:
			expectedToken(parent->addChild(new Node(parent,sym)), TERM)
			break;
		case SP_NON_TERM:
			expectedToken(parent->addChild(new Node(parent,sym)), SP_NON_TERM)
			break;
		default:
			throw runtime_error(
				"UnexpectedTokenInParseIdent:"
				+string(Domains[sym->tag])
				+"\n");
	}
}
